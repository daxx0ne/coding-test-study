# BOJ-2504

### 문제 규칙

1. `() -> 2`
2. `[] -> 3`
3. `(x) -> x * 2`
4. `[x] -> x * 3`
5. `(xy) -> (x+y) * 2`

=> `[([])(())] -> 3 * (2*3 + 2*2)`

### 아이디어

```
1. 스택 배열을 생성하여, 입력한 문자열 순차적으로 확인
2. 괄호들을 숫자로 생각하여 풀이
    2-1. ( ( [  ] ) )는 아래와 같이 나타낼 수 있음.
         2 4 12
    2-2. 하지만 위 방법만을 생각하여 푸는 경우, 아래의 예시와 같이 이후에 나오는 값들에 대해 처리를 하지 못함.
        ( ) ( ) ( )
        2   4   8
    2-3. 닫히는 괄호가 나올 경우, 문제 규칙에 나온 값을 나누어 주기
        ( ( [  ] ) )
        2 4 12 4 2 1

        ( ) ( ) ( )
        2 1 2 1 2 1
    2-4. 덧셈이 언제 이루어질지를 생각.
        ( ( [ ] ) ) 의 경우에는 ]가 처음으로 나올 때만 덧셈이 이루어짐
            -> (([])) 를 숫자로 생각한 값을 보았을 때, 12를 더해야 하기 때문에 [로 생각할 수 있음
            -> 하지만 닫히는 괄호가 나오는 것을 본 후에, 덧셈을 진행해야 하기 때문에
            -> 닫히는 괄호가 나왔을 때 현재 진행되고 있는 숫자를 더해준 후에, 숫자를 나누는 방식으로 진행

        ( ) ( ) ( ) 의 경우에는 () () () 각각에 대해 2+2+2 로 덧셈.

        => 즉, 여는 괄호가 나온 후에 첫 닫히는 괄호가 나올 때만 덧셈을 진행
3. 배열을 순차적으로 진행
    3-1. 여는 괄호가 나올 경우
        3-1-1. 스택에 삽입한 후, 숫자에 괄호의 값을 곱하기
        3-1-2. 다음으로 나오는 닫기 괄호에 대해 덧셈을 허용하기 위해 isAdd 변수를 True로 설정
    3-2. 닫는 괄호가 나올 경우
        3-2-1. 스택에 삽입하기 전, 스택의 마지막 값이 해당 괄호의 여는 괄호일 경우에만 진입
        3-2-2. 처음으로 닫는 괄호가 나올 경우 isAdd가 True이기 때문에 값을 answer에 더해준 후에 isAdd를 False로 설정
        3-2-3. 현재 진행되고 있는 숫자에 대해 괄호의 값으로 나누기
5. 마지막으로 스택 배열을 확인
    5-1. 만약 스택 배열의 크기가 1보다 크다면(초기에 0을 넣어서 IndexError를 방지), 정상적으로 괄호들이 처리 되지 않았다는 의미로 0을 출력
    5-2. 아니라면, 정상적으로 answer 출력

```

### IndexError가 발생한 부분

```
stack = []
for paren in quiz:
    if paren == ')' and stack[-1] == '(':
        if isAdd:
            answer += current_num
            isAdd = False
        current_num //= 2
        stack.pop()
```

stack[-1]을 통해 마지막 값을 비교하였는데, 초기 배열에는 아무런 값이 존재하지 않아 인덱스 에러가 발생.

이를 대처하기 위해, stack 배열에 0을 넣고 진행
